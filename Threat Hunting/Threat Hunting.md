# Threat Hunting Queries & Hypotheses

**Author:** Jacob Phillips | Cloud Security Engineer | SC-200 Certified
**Tools:** Microsoft Sentinel, Microsoft Defender for Endpoint, Elastic SIEM
**Last Updated:** February 2026

---

## Table of Contents

1. [Introduction](#introduction)
2. [Threat Hunting Methodology](#threat-hunting-methodology)
3. [Data Sources](#data-sources)
4. [Hunt 1 - Living Off the Land Binary (LOLBin) Abuse](#hunt-1--living-off-the-land-binary-lolbin-abuse)
5. [Hunt 2 - Suspicious DNS Activity / DNS Tunneling](#hunt-2--suspicious-dns-activity--dns-tunneling)
6. [Hunt 3 - Lateral Movement via Remote Services](#hunt-3--lateral-movement-via-remote-services)
7. [Hunt 4 - Persistence via Scheduled Tasks and Services](#hunt-4--persistence-via-scheduled-tasks-and-services)
8. [Hunt 5 - Credential Access via LSASS](#hunt-5--credential-access-via-lsass)
9. [Hunt 6 - Azure AD Suspicious Activity](#hunt-6--azure-ad-suspicious-activity)
10. [Hunt 7 - Data Staging and Exfiltration Preparation](#hunt-7--data-staging-and-exfiltration-preparation)
11. [Hunt 8 - Email-Based Initial Access Indicators](#hunt-8--email-based-initial-access-indicators)
12. [Operationalizing Threat Hunting](#operationalizing-threat-hunting)
13. [References](#references)

---

## Introduction

### What Is Threat Hunting?

Threat hunting is the proactive, analyst-driven practice of searching through networks and datasets to detect threats that have evaded existing automated defenses. Unlike reactive security operations, where analysts respond to alerts generated by detection rules, threat hunting assumes that an adversary may already be present in the environment and seeks to find evidence of compromise before damage is done.

The distinction is critical. Reactive security (alert triage, incident response to fired rules) will always lag behind adversary innovation. Detection rules can only catch what they were written to catch. Threat hunting closes that gap by applying human intuition, adversary knowledge, and creative analysis to data that already exists in the environment but has not triggered an alert.

In practice, a mature security program runs both in parallel. Detection engineering handles the known-known threats through automated alerting. Threat hunting handles the known-unknown and unknown-unknown threats through structured, hypothesis-driven investigation. The two disciplines feed each other: hunts that discover new attacker behavior become new detection rules, and detection gaps identified during incident response become new hunting hypotheses.

### Why Threat Hunting Matters

- **Dwell time reduction.** The industry median for attacker dwell time (time between initial compromise and detection) remains measured in weeks to months. Every hunt that finds a compromise early directly reduces the blast radius of that incident.
- **Detection gap identification.** Hunts routinely uncover blind spots in logging coverage, rule logic, and sensor deployment. These findings strengthen the overall detection posture even when no active threat is found.
- **Adversary understanding.** Regular hunting keeps analysts current on real-world TTPs. This knowledge transfers directly into better alert triage, faster incident response, and more effective detection engineering.
- **Compliance and assurance.** Regulated industries increasingly expect evidence of proactive threat detection beyond automated tooling. A documented hunting program satisfies audit requirements and demonstrates due diligence.

### Hypothesis-Driven Hunting

Every hunt in this document follows a hypothesis-driven approach. Rather than undirected data exploration, each hunt begins with a specific, falsifiable hypothesis about adversary behavior in the environment. This approach provides structure, ensures hunts are scoped and completable, and produces clear outcomes (hypothesis confirmed, refuted, or inconclusive due to data gaps).

A well-formed hunting hypothesis has three components:

1. **A specific adversary behavior.** What TTP are we looking for?
2. **An environmental context.** Why might this behavior occur in our environment?
3. **Observable indicators.** What evidence would we expect to find in our data if the hypothesis is true?

---

## Threat Hunting Methodology

Each hunt follows a four-phase lifecycle:

### Phase 1: Hypothesis Formation

The hunt begins with a hypothesis derived from one or more of the following sources:

- **Threat intelligence.** New reports of campaigns targeting our industry or technology stack.
- **MITRE ATT&CK gap analysis.** Techniques that our detection rules do not cover or cover weakly.
- **Incident retrospectives.** TTPs observed in past incidents that may recur or that peer organizations have reported.
- **Environmental changes.** New cloud services, applications, or network segments that introduce new attack surface.
- **Anomaly observations.** Patterns noticed during routine alert triage that warrant deeper investigation.

### Phase 2: Data Collection and Exploration

With a hypothesis in hand, the hunter identifies the required data sources and constructs queries to surface relevant evidence. This phase includes:

- Validating that the necessary telemetry exists and is ingested (log coverage check).
- Writing and iterating on queries (KQL for Sentinel/Defender, EQL/Lucene for Elastic).
- Establishing baselines for normal behavior so that anomalies can be identified.
- Enriching results with contextual data (asset inventory, user role, geographic location, threat intelligence).

### Phase 3: Investigation and Analysis

Query results are analyzed to determine whether the hypothesis is supported. This involves:

- Filtering false positives based on known-good activity and environmental context.
- Pivoting on interesting findings (examining related events, expanding the time window, correlating across data sources).
- Building a timeline of activity for any confirmed or suspected true positives.
- Assessing the scope and severity of any findings.

### Phase 4: Resolution and Output

Every hunt produces one of three outcomes:

- **True positive found.** The hypothesis is confirmed. Findings are escalated to incident response. Detection rules are created or tuned to catch this activity going forward.
- **No findings (hypothesis not confirmed).** The environment appears clean for this behavior during the hunting period. The hunt is documented, and the hypothesis may be revisited in future cycles with updated intelligence.
- **Data gap identified.** The hunt could not be completed because required telemetry is missing or insufficient. A recommendation is made to improve logging coverage.

Regardless of outcome, every hunt is documented with its hypothesis, queries, findings, and recommendations. This documentation feeds the detection engineering pipeline and builds institutional knowledge.

---

## Data Sources

The hunts in this document rely on the following data sources available in our Microsoft Sentinel and Defender for Endpoint deployment:

| Data Source | Table(s) | Coverage |
|---|---|---|
| Endpoint process execution | `DeviceProcessEvents` | All managed Windows endpoints |
| Endpoint network connections | `DeviceNetworkEvents` | All managed endpoints |
| Endpoint file activity | `DeviceFileEvents` | All managed endpoints |
| Endpoint logon events | `DeviceLogonEvents` | All managed endpoints |
| Endpoint registry events | `DeviceRegistryEvents` | All managed endpoints |
| DNS query logs | `DnsEvents`, `DeviceNetworkEvents` | Network DNS servers, endpoint DNS client |
| Azure AD sign-in logs | `SigninLogs`, `AADNonInteractiveUserSignInLogs` | All Azure AD authentication |
| Azure AD audit logs | `AuditLogs` | All Azure AD administrative actions |
| Email events | `EmailEvents`, `EmailUrlInfo`, `EmailAttachmentInfo` | Microsoft Defender for Office 365 |
| Cloud app activity | `CloudAppEvents` | Defender for Cloud Apps |
| Windows Security Events | `SecurityEvent`, `DeviceEvents` | Domain controllers, critical servers |

---

## Hunt 1 — Living Off the Land Binary (LOLBin) Abuse

### Hypothesis

Attackers are using legitimate, Microsoft-signed Windows binaries to download payloads, execute arbitrary code, or bypass application control policies. These binaries are already present on every Windows system and are trusted by default, making them attractive for adversaries who want to avoid deploying custom malware.

### MITRE ATT&CK Mapping

| Field | Value |
|---|---|
| **Tactic** | Defense Evasion (TA0005), Execution (TA0002) |
| **Technique** | T1218 — Signed Binary Proxy Execution |
| **Sub-techniques** | T1218.005 (Mshta), T1218.010 (Regsvr32), T1218.011 (Rundll32) |

### Required Data Sources

- `DeviceProcessEvents` (Defender for Endpoint)

### Hunting Query (KQL)

```kql
// Hunt: LOLBin Abuse - Suspicious use of signed Windows binaries
// Scope: Last 7 days across all managed endpoints
let LolBins = dynamic(["mshta.exe", "certutil.exe", "rundll32.exe", "regsvr32.exe",
    "cmstp.exe", "msxsl.exe", "wmic.exe", "msiexec.exe", "forfiles.exe",
    "pcalua.exe", "csc.exe", "installutil.exe"]);
let SuspiciousPatterns = dynamic(["http://", "https://", "ftp://",
    "javascript:", "vbscript:", "scriptlet:", "-decode", "-urlcache",
    "/i:http", "-enc ", "-encodedcommand", "bypass", "hidden",
    "downloadstring", "downloadfile", "invoke-expression",
    "scrobj.dll", "comsvcs.dll", "/ddeauto", "-nop "]);
DeviceProcessEvents
| where Timestamp > ago(7d)
| where FileName in~ (LolBins)
| where ProcessCommandLine has_any (SuspiciousPatterns)
// Exclude known legitimate activity - tune these to your environment
| where not(ProcessCommandLine has_all ("certutil", "-hashfile"))
| where not(InitiatingProcessFileName in~ ("sccm.exe", "ccmexec.exe"))
| project
    Timestamp,
    DeviceName,
    AccountName,
    FileName,
    ProcessCommandLine,
    InitiatingProcessFileName,
    InitiatingProcessCommandLine,
    FolderPath,
    ProcessId,
    InitiatingProcessId
| extend BinaryUsed = FileName,
    CommandLineLength = strlen(ProcessCommandLine),
    HasUrl = ProcessCommandLine matches regex @"https?://",
    HasEncodedContent = ProcessCommandLine has_any ("-enc", "-encode", "base64")
| sort by Timestamp desc
```

### Expected Findings

When this query returns results, examine the following:

- **certutil.exe** with `-urlcache -split -f` or `-decode` flags indicates potential payload download or Base64 decoding of staged files.
- **mshta.exe** with URLs or inline script indicates execution of remote HTML applications, often used to run VBScript/JScript payloads.
- **rundll32.exe** called with unusual DLLs, especially from Temp, AppData, or ProgramData directories, or with `javascript:` protocol handlers.
- **regsvr32.exe** with `/i:http` indicates the Squiblydoo technique, loading remote SCT (scriptlet) files to execute arbitrary code.
- **wmic.exe** with `process call create` or XSL stylesheet references can indicate remote code execution or WMIC-based application whitelisting bypass.

### Triage Steps

1. **Examine the full process tree.** Use the `InitiatingProcessFileName` and `InitiatingProcessId` to walk up the process chain. A LOLBin launched by `explorer.exe` after a user double-clicked a file tells a different story than one launched by `cmd.exe` spawned from `winword.exe`.
2. **Check the target URL or file path.** If the LOLBin is downloading content, investigate the source URL or the file being decoded. Query `DeviceNetworkEvents` for the associated connection and `DeviceFileEvents` for any files written.
3. **Review the user context.** Is this user expected to run administrative tools? Cross-reference with HR data and role-based expectations.
4. **Check for related activity.** Query for other suspicious events from the same device and user within a +/- 2 hour window.
5. **Validate against software deployment records.** Some legitimate software installers use these binaries in ways that match suspicious patterns.

### False Positive Guidance

| Binary | Common False Positive | Distinguishing Factor |
|---|---|---|
| certutil.exe | Certificate enrollment, SCCM operations | Initiated by SCCM/PKI infrastructure processes |
| rundll32.exe | Shell extension loading, Control Panel items | Known DLL paths within System32 |
| msiexec.exe | Legitimate software installation | Initiated by software deployment tools (SCCM, Intune) |
| csc.exe | .NET application compilation during development | Initiated by Visual Studio, MSBuild on developer machines |

### Recommended Response Actions

- If a true positive is confirmed, isolate the affected endpoint using Defender for Endpoint live response.
- Collect a forensic image or memory dump before remediation.
- Block the identified URL/IP at the proxy and firewall.
- Submit the downloaded payload to a sandbox for analysis.
- Create a detection rule based on the specific LOLBin and command-line pattern observed.

---

## Hunt 2 — Suspicious DNS Activity / DNS Tunneling

### Hypothesis

Adversaries are using the DNS protocol for command-and-control communication or data exfiltration. Because DNS traffic is almost universally allowed through firewalls and is rarely inspected at the content level, it provides a reliable covert channel. DNS tunneling encodes data in DNS query names and responses, often using long subdomain strings and high query volumes to a single domain.

### MITRE ATT&CK Mapping

| Field | Value |
|---|---|
| **Tactic** | Command and Control (TA0011), Exfiltration (TA0010) |
| **Technique** | T1071.004 — Application Layer Protocol: DNS |
| **Related** | T1048.003 — Exfiltration Over Alternative Protocol |

### Required Data Sources

- `DnsEvents` (DNS server logs via Sentinel connector)
- `DeviceNetworkEvents` (Defender for Endpoint, port 53 traffic)

### Hunting Query (KQL)

```kql
// Hunt: DNS Tunneling Detection - High volume, high entropy DNS queries
// Scope: Last 7 days
// Phase 1: Identify domains with abnormal query patterns
let TimeWindow = 7d;
let MinQueryCount = 200;         // Minimum queries to a single domain to be suspicious
let MinAvgSubdomainLen = 25;     // Avg subdomain length threshold (tunneling encodes data here)
let EntropyThreshold = 3.5;      // Shannon entropy threshold for subdomain randomness
// Known CDN and legitimate high-volume domains to exclude
let ExcludedDomains = dynamic([
    "microsoft.com", "windows.com", "windowsupdate.com", "azure.com",
    "office365.com", "office.com", "msftconnecttest.com", "live.com",
    "google.com", "googleapis.com", "gstatic.com", "amazonaws.com",
    "cloudflare.com", "akamai.net", "akadns.net", "trafficmanager.net"
]);
DnsEvents
| where TimeGenerated > ago(TimeWindow)
| where QueryType in ("A", "AAAA", "TXT", "CNAME", "MX", "NULL")
| extend FullQuery = Name
| extend DomainParts = split(Name, ".")
| extend TopDomain = strcat(tostring(DomainParts[-2]), ".", tostring(DomainParts[-1]))
| where not(TopDomain has_any (ExcludedDomains))
// Extract the subdomain portion (everything before the registered domain)
| extend SubdomainPortion = substring(Name, 0, indexof(Name, TopDomain) - 1)
| extend SubdomainLength = strlen(SubdomainPortion)
| where SubdomainLength > 0
// Aggregate per parent domain
| summarize
    TotalQueries = count(),
    UniqueSubdomains = dcount(SubdomainPortion),
    AvgSubdomainLength = avg(SubdomainLength),
    MaxSubdomainLength = max(SubdomainLength),
    TxtQueryCount = countif(QueryType == "TXT"),
    NullQueryCount = countif(QueryType == "NULL"),
    QueryingHosts = dcount(ClientIP),
    SampleQueries = make_set(Name, 5),
    FirstSeen = min(TimeGenerated),
    LastSeen = max(TimeGenerated)
    by TopDomain
| where TotalQueries >= MinQueryCount
| where AvgSubdomainLength >= MinAvgSubdomainLen
// Score the domain based on tunneling indicators
| extend TunnelingScore =
    iif(AvgSubdomainLength > 40, 3, iif(AvgSubdomainLength > 30, 2, 1)) +
    iif(TotalQueries > 1000, 3, iif(TotalQueries > 500, 2, 1)) +
    iif(UniqueSubdomains > 500, 3, iif(UniqueSubdomains > 100, 2, 1)) +
    iif(TxtQueryCount > 50, 2, 0) +
    iif(NullQueryCount > 0, 2, 0)
| where TunnelingScore >= 6
| sort by TunnelingScore desc, TotalQueries desc
| project
    TopDomain,
    TunnelingScore,
    TotalQueries,
    UniqueSubdomains,
    AvgSubdomainLength,
    MaxSubdomainLength,
    TxtQueryCount,
    NullQueryCount,
    QueryingHosts,
    SampleQueries,
    FirstSeen,
    LastSeen
```

### Baseline Comparison Query

```kql
// Supplemental: Compare current DNS volume against 30-day baseline per domain
let CurrentPeriod = 1d;
let BaselinePeriod = 30d;
let CurrentData = DnsEvents
    | where TimeGenerated > ago(CurrentPeriod)
    | extend TopDomain = strcat(tostring(split(Name, ".")[-2]), ".", tostring(split(Name, ".")[-1]))
    | summarize CurrentQueries = count() by TopDomain;
let BaselineData = DnsEvents
    | where TimeGenerated between (ago(BaselinePeriod) .. ago(CurrentPeriod))
    | extend TopDomain = strcat(tostring(split(Name, ".")[-2]), ".", tostring(split(Name, ".")[-1]))
    | summarize BaselineDailyAvg = count() / 29.0 by TopDomain;
CurrentData
| join kind=leftouter BaselineData on TopDomain
| extend DeviationFactor = iff(BaselineDailyAvg > 0, CurrentQueries / BaselineDailyAvg, 999.0)
| where DeviationFactor > 5.0 or isempty(BaselineDailyAvg)
| sort by DeviationFactor desc
| project TopDomain, CurrentQueries, BaselineDailyAvg, DeviationFactor
```

### Indicators of DNS Tunneling vs. Normal Behavior

| Indicator | Normal DNS | DNS Tunneling |
|---|---|---|
| Subdomain length | 5-20 characters | 30-63 characters (max label length) |
| Subdomain entropy | Low (readable words) | High (encoded/encrypted data) |
| Query volume to single domain | Varies, but moderate | Hundreds to thousands per hour |
| Query types | Predominantly A/AAAA | Heavy TXT, NULL, or CNAME usage |
| Unique subdomain ratio | Low (cached, repeated) | Very high (each query carries unique data) |
| Timing pattern | Bursty around user activity | Steady, periodic (beaconing) |

### Triage Steps

1. **Examine sample queries.** Look at the actual subdomain strings. Tunneling produces Base32/Base64-like strings. Legitimate CDNs produce readable or structured subdomains.
2. **Check the domain registration.** Query WHOIS for the parent domain. Recently registered domains or domains registered through privacy services raise the risk score.
3. **Correlate with endpoint data.** Identify which process on the querying host is generating the DNS traffic by joining with `DeviceNetworkEvents` on timestamp and client IP.
4. **Check threat intelligence.** Query the domain against threat intelligence feeds and VirusTotal.
5. **Analyze query timing.** Plot the query timestamps on a timeline. Consistent intervals suggest automated beaconing.

### False Positive Guidance

- **Content delivery networks** may generate high-volume, long-subdomain queries. Exclude known CDN domains after validation.
- **Anti-virus and security tools** sometimes use DNS-based lookups (e.g., DNS reputation queries) with encoded hashes in subdomains.
- **DKIM/DMARC verification** can produce long DNS TXT queries. These typically target known mail infrastructure domains.
- **SaaS applications** with DNS-based service discovery may generate unusual patterns. Validate against known application infrastructure.

### Recommended Response Actions

- If DNS tunneling is confirmed, identify and isolate the affected host immediately.
- Block the parent domain at the DNS resolver and firewall.
- Capture network traffic from the affected host for protocol analysis (Wireshark/Zeek).
- Determine the tunneling tool in use (iodine, dnscat2, Cobalt Strike DNS beacon) to assess adversary capability.
- Review the host for additional persistence mechanisms, as DNS C2 implies an established foothold.

---

## Hunt 3 — Lateral Movement via Remote Services

### Hypothesis

Compromised accounts are being used to move laterally through the environment using legitimate remote access protocols. In most enterprise environments, workstation-to-workstation remote connections are rare. Servers initiate management connections to workstations (SCCM, GPO), and administrators connect from jump servers to infrastructure. Direct workstation-to-workstation RDP, SMB, WinRM, or PowerShell Remoting sessions are abnormal and may indicate an attacker pivoting through the network.

### MITRE ATT&CK Mapping

| Field | Value |
|---|---|
| **Tactic** | Lateral Movement (TA0008) |
| **Technique** | T1021 — Remote Services |
| **Sub-techniques** | T1021.001 (RDP), T1021.002 (SMB/Admin Shares), T1021.006 (WinRM) |

### Required Data Sources

- `DeviceNetworkEvents` (Defender for Endpoint)
- `DeviceLogonEvents` (Defender for Endpoint)
- `SecurityEvent` (Windows Security Event Log, Event IDs 4624, 4625)

### Hunting Query (KQL)

```kql
// Hunt: Lateral Movement - Unusual workstation-to-workstation remote connections
// Scope: Last 7 days
// Approach: Identify remote logon events between devices where neither is a known server
let TimeWindow = 7d;
// Define known server naming patterns - adjust to match your environment
let ServerPatterns = dynamic(["SRV", "DC-", "SQL-", "WEB-", "APP-", "MGMT-", "JUMP-"]);
let RemoteServicePorts = dynamic([3389, 445, 5985, 5986, 22]);
// Step 1: Find network connections on remote service ports between non-server devices
let RemoteConnections = DeviceNetworkEvents
    | where Timestamp > ago(TimeWindow)
    | where RemotePort in (RemoteServicePorts) and ActionType == "ConnectionSuccess"
    // Exclude connections to known servers by naming convention
    | where not(RemoteUrl has_any (ServerPatterns))
    | where not(DeviceName has_any (ServerPatterns))
    | extend SourceDevice = tostring(DeviceName),
        DestinationIP = tostring(RemoteIP),
        DestinationPort = RemotePort,
        Protocol = case(
            RemotePort == 3389, "RDP",
            RemotePort == 445, "SMB",
            RemotePort in (5985, 5986), "WinRM",
            RemotePort == 22, "SSH",
            "Other"
        )
    | project Timestamp, SourceDevice, DestinationIP, DestinationPort,
        Protocol, InitiatingProcessFileName, InitiatingProcessCommandLine,
        InitiatingProcessAccountName;
// Step 2: Correlate with logon events to identify the account used
let RemoteLogons = DeviceLogonEvents
    | where Timestamp > ago(TimeWindow)
    | where LogonType in ("RemoteInteractive", "Network", "NetworkCleartext")
    | where ActionType == "LogonSuccess"
    | where not(DeviceName has_any (ServerPatterns))
    | project LogonTimestamp = Timestamp, TargetDevice = DeviceName,
        LogonType, AccountName, AccountDomain,
        RemoteIP, RemoteDeviceName,
        IsLocalAdmin;
// Step 3: Combine and analyze
RemoteConnections
| summarize
    ConnectionCount = count(),
    FirstConnection = min(Timestamp),
    LastConnection = max(Timestamp),
    ProtocolsUsed = make_set(Protocol),
    ProcessesUsed = make_set(InitiatingProcessFileName),
    AccountsUsed = make_set(InitiatingProcessAccountName)
    by SourceDevice, DestinationIP
// Flag devices with multiple protocols or high connection counts
| extend RiskScore = iif(array_length(ProtocolsUsed) > 1, 2, 0) +
    iif(ConnectionCount > 10, 2, 0) +
    iif(array_length(AccountsUsed) > 1, 3, 0)
| where ConnectionCount > 3 or array_length(ProtocolsUsed) > 1
| sort by RiskScore desc, ConnectionCount desc
```

### Time-Based Anomaly Detection

```kql
// Supplemental: Detect remote connections occurring outside business hours
// These are more likely to be attacker activity
DeviceLogonEvents
| where Timestamp > ago(7d)
| where LogonType in ("RemoteInteractive", "Network")
| where ActionType == "LogonSuccess"
| extend HourOfDay = hourofday(Timestamp), DayOfWeek = dayofweek(Timestamp)
// Outside business hours: before 6 AM, after 8 PM, or weekends
| where HourOfDay < 6 or HourOfDay > 20
    or DayOfWeek == 0d or DayOfWeek == 6d
| where not(DeviceName has_any (dynamic(["SRV", "DC-", "SQL-"])))
| project Timestamp, DeviceName, AccountName, AccountDomain,
    LogonType, RemoteIP, RemoteDeviceName, HourOfDay, DayOfWeek
| summarize
    OffHoursLogons = count(),
    Devices = make_set(DeviceName),
    SourceIPs = make_set(RemoteIP)
    by AccountName, AccountDomain
| where OffHoursLogons > 2
| sort by OffHoursLogons desc
```

### Expected Findings

- **Single device connecting to many workstations** on port 445 or 3389 — classic lateral movement pattern.
- **One account authenticating to multiple workstations** in rapid succession — account compromise and network enumeration.
- **Use of multiple remote protocols** from a single source (RDP + SMB + WinRM) — attacker testing access methods.
- **Connections from workstations to workstations** outside business hours — unlikely to be legitimate user activity.

### Triage Steps

1. **Verify the source and destination devices.** Confirm that neither is a misclassified server or IT admin workstation. Cross-reference with the CMDB/asset inventory.
2. **Verify the account.** Is this an IT administrator with a legitimate need for remote access? Check role assignment and recent helpdesk tickets.
3. **Examine the process context.** What process initiated the connection? `mstsc.exe` for RDP is expected; `powershell.exe` or `cmd.exe` spawning SMB connections may be more concerning.
4. **Look for a pattern.** One connection may be benign. A sequence of connections to multiple hosts suggests enumeration or lateral movement.
5. **Correlate with authentication failures.** Query `DeviceLogonEvents` for failed logon attempts from the same source, which may indicate password spraying before a successful lateral move.

### False Positive Guidance

- **IT administrators** performing remote support may trigger these detections. Maintain an exclusion list of known admin workstations and accounts, but review the exclusion list quarterly.
- **Remote desktop tools** (e.g., remote support software) may use RDP under the hood. Identify these tools by their process names and exclude them specifically.
- **Network scanning tools** used by the security team (vulnerability scanners, asset discovery) will generate SMB connections. Exclude known scanner source IPs.
- **Shared workstations** in lab or training environments may show unusual patterns. Tag these in the asset inventory and handle separately.

### Recommended Response Actions

- If unauthorized lateral movement is confirmed, disable the compromised account immediately.
- Isolate both the source and destination devices.
- Audit all devices the compromised account has accessed in the past 30 days.
- Reset credentials and revoke active sessions for the affected account.
- Check destination devices for new persistence mechanisms (scheduled tasks, services, registry run keys).

---

## Hunt 4 — Persistence via Scheduled Tasks and Services

### Hypothesis

Attackers have established persistence on compromised endpoints by creating scheduled tasks or installing new Windows services. These are among the most common persistence mechanisms because they survive reboots, can run with elevated privileges, and are easy to configure. Adversaries often create tasks or services that execute payloads from temporary directories, user profile folders, or other non-standard locations.

### MITRE ATT&CK Mapping

| Field | Value |
|---|---|
| **Tactic** | Persistence (TA0003), Execution (TA0002) |
| **Technique** | T1053.005 — Scheduled Task, T1543.003 — Windows Service |

### Required Data Sources

- `DeviceProcessEvents` (Defender for Endpoint)
- `DeviceEvents` (Defender for Endpoint — ScheduledTaskCreated, ServiceInstalled)
- `DeviceRegistryEvents` (Defender for Endpoint)

### Hunting Query (KQL)

```kql
// Hunt: Persistence - Newly created scheduled tasks running from suspicious paths
// Scope: Last 14 days
let TimeWindow = 14d;
let SuspiciousPaths = dynamic([
    "\\temp\\", "\\tmp\\", "\\appdata\\local\\temp\\",
    "\\appdata\\roaming\\", "\\programdata\\",
    "\\users\\public\\", "\\perflogs\\",
    "\\windows\\temp\\", "\\recycle",
    "$recycle.bin", "\\downloads\\"
]);
let LegitimateTaskCreators = dynamic([
    "svchost.exe", "msiexec.exe", "setuphost.exe",
    "ccmexec.exe", "intune", "microsoftedgeupdate.exe"
]);
// Part 1: Scheduled task creation events
let ScheduledTasks = DeviceEvents
    | where Timestamp > ago(TimeWindow)
    | where ActionType == "ScheduledTaskCreated"
    | extend TaskName = tostring(parse_json(AdditionalFields).TaskName),
        TaskContent = tostring(parse_json(AdditionalFields).TaskContent)
    | extend TaskAction = extract(@"<Command>(.*?)</Command>", 1, TaskContent),
        TaskArguments = extract(@"<Arguments>(.*?)</Arguments>", 1, TaskContent)
    | where isnotempty(TaskAction)
    // Filter for tasks running from suspicious paths
    | where TaskAction has_any (SuspiciousPaths)
        or TaskArguments has_any (SuspiciousPaths)
    // Exclude known legitimate task creators
    | where not(InitiatingProcessFileName in~ (LegitimateTaskCreators))
    | project
        Timestamp,
        DeviceName,
        TaskName,
        TaskAction,
        TaskArguments,
        InitiatingProcessFileName,
        InitiatingProcessCommandLine,
        InitiatingProcessAccountName,
        PersistenceType = "ScheduledTask";
// Part 2: New service installation via registry
let NewServices = DeviceRegistryEvents
    | where Timestamp > ago(TimeWindow)
    | where RegistryKey has @"HKLM\SYSTEM\CurrentControlSet\Services"
    | where RegistryValueName == "ImagePath"
    | where ActionType == "RegistryValueSet"
    | extend ServiceImagePath = RegistryValueData
    | where ServiceImagePath has_any (SuspiciousPaths)
    // Exclude known system services
    | where not(ServiceImagePath has_any ("windows\\system32", "program files"))
    | project
        Timestamp,
        DeviceName,
        TaskName = extract(@"Services\\(.+?)$", 1, RegistryKey),
        TaskAction = ServiceImagePath,
        TaskArguments = "",
        InitiatingProcessFileName,
        InitiatingProcessCommandLine,
        InitiatingProcessAccountName,
        PersistenceType = "WindowsService";
// Combine and deduplicate
union ScheduledTasks, NewServices
| sort by Timestamp desc
| project-reorder Timestamp, DeviceName, PersistenceType, TaskName, TaskAction,
    TaskArguments, InitiatingProcessFileName, InitiatingProcessAccountName
```

### Supplemental Query: Schtasks.exe Command-Line Abuse

```kql
// Detect direct use of schtasks.exe to create tasks (common in attack scripts)
DeviceProcessEvents
| where Timestamp > ago(7d)
| where FileName =~ "schtasks.exe"
| where ProcessCommandLine has "/create"
| where ProcessCommandLine has_any (
    "\\temp\\", "\\appdata\\", "\\public\\",
    "powershell", "cmd.exe /c", "mshta",
    "certutil", "bitsadmin", "rundll32",
    "-enc ", "-encodedcommand", "bypass",
    "downloadstring", "invoke-expression",
    "http://", "https://"
)
// Exclude SYSTEM creating tasks during patching
| where InitiatingProcessAccountName !~ "SYSTEM"
    or InitiatingProcessFileName !in~ ("svchost.exe", "tiworker.exe")
| project Timestamp, DeviceName, AccountName,
    ProcessCommandLine, InitiatingProcessFileName,
    InitiatingProcessCommandLine
| sort by Timestamp desc
```

### Expected Findings

- Scheduled tasks that execute PowerShell scripts, batch files, or executables from Temp, AppData, ProgramData, or Downloads directories.
- Services with ImagePath values pointing to non-standard locations.
- Tasks created by `cmd.exe` or `powershell.exe` rather than by standard software installation processes.
- Tasks with obfuscated names that mimic legitimate Windows tasks (e.g., "WindowsUpdateCheck", "SystemHealthMonitor").

### Triage Steps

1. **Examine the task action/image path.** What binary does it execute? Is the binary known or unknown? Check the hash against threat intelligence.
2. **Check the creation context.** What process created the task? Walk up the process tree. A task created by `powershell.exe` which was spawned by `winword.exe` is a high-confidence indicator of compromise.
3. **Review the task schedule.** Tasks set to run at logon, on a very frequent interval (minutes), or at unusual hours are more suspicious than daily maintenance tasks.
4. **Check if the binary still exists.** Query `DeviceFileEvents` for the file referenced in the task action. If it has been deleted or changed since task creation, that is notable.
5. **Look for related persistence.** Attackers often establish multiple persistence mechanisms. Search the same device for registry run key modifications, startup folder additions, and other scheduled tasks.

### False Positive Guidance

- **Software installations** may create scheduled tasks from AppData or ProgramData. Correlate with software deployment timelines and known installer processes.
- **Browser and application updaters** (Chrome, Edge, Adobe) create scheduled tasks from user profile paths. These typically have well-known task names and signed executables.
- **SCCM/Intune operations** create and modify scheduled tasks as part of patch management. Exclude tasks created by management agent processes.

### Recommended Response Actions

- If a malicious scheduled task or service is confirmed, do not simply delete it. First, document the task configuration, the binary it runs, and the process that created it.
- Collect the referenced binary for malware analysis.
- Remove the persistence mechanism and quarantine the binary.
- Investigate the full attack chain: how did the attacker gain the access needed to create the task?
- Create a detection rule for the specific task creation pattern observed.

---

## Hunt 5 — Credential Access via LSASS

### Hypothesis

Attackers are dumping credentials from the Local Security Authority Subsystem Service (LSASS) process memory. LSASS stores credentials for authenticated users, including NTLM hashes, Kerberos tickets, and in some configurations, plaintext passwords. Credential dumping from LSASS is one of the most impactful attacker actions because it enables lateral movement, privilege escalation, and domain compromise.

### MITRE ATT&CK Mapping

| Field | Value |
|---|---|
| **Tactic** | Credential Access (TA0006) |
| **Technique** | T1003.001 — OS Credential Dumping: LSASS Memory |

### Required Data Sources

- `DeviceProcessEvents` (Defender for Endpoint)
- `DeviceEvents` (Defender for Endpoint — process access events)
- `DeviceFileEvents` (Defender for Endpoint)

### Hunting Query (KQL)

```kql
// Hunt: LSASS Credential Dumping - Multiple detection vectors
// Scope: Last 7 days
let TimeWindow = 7d;
// Vector 1: Known credential dumping tools and command-line patterns
let ToolBasedDumping = DeviceProcessEvents
    | where Timestamp > ago(TimeWindow)
    | where (
        // Mimikatz indicators
        ProcessCommandLine has_any ("sekurlsa", "logonpasswords", "kerberos::list",
            "crypto::certificates", "lsadump", "privilege::debug")
        // ProcDump targeting LSASS
        or (FileName =~ "procdump.exe" and ProcessCommandLine has "lsass")
        or (FileName =~ "procdump64.exe" and ProcessCommandLine has "lsass")
        // comsvcs.dll MiniDump technique
        or (ProcessCommandLine has "comsvcs.dll" and ProcessCommandLine has_any
            ("MiniDump", "minidump", "#24"))
        // Task Manager dump (less common in attacks but worth tracking)
        or (FileName =~ "taskmgr.exe" and ProcessCommandLine has "lsass")
        // Rundll32 with comsvcs
        or (FileName =~ "rundll32.exe" and ProcessCommandLine has "comsvcs"
            and ProcessCommandLine has_any ("full", "mini", "#24"))
        // nanodump, handlekatz, and other modern tools
        or ProcessCommandLine has_any ("nanodump", "handlekatz", "SafetyKatz",
            "SharpKatz", "pypykatz")
    )
    | project Timestamp, DeviceName, AccountName, FileName,
        ProcessCommandLine, InitiatingProcessFileName,
        InitiatingProcessCommandLine, FolderPath,
        DetectionVector = "KnownTool";
// Vector 2: Suspicious process access to LSASS
let ProcessAccessToLSASS = DeviceEvents
    | where Timestamp > ago(TimeWindow)
    | where ActionType == "ProcessAccessed"
    | where FileName =~ "lsass.exe"
    // Focus on access masks that indicate memory read (0x1010, 0x1410, 0x1F1FFF)
    | extend AccessMask = tostring(parse_json(AdditionalFields).AccessMask)
    | where not(InitiatingProcessFileName in~ (
        "svchost.exe", "lsass.exe", "csrss.exe", "wininit.exe",
        "services.exe", "mrt.exe", "taskmgr.exe", "wmiprvse.exe",
        "MsMpEng.exe", "SenseIR.exe", "MsSense.exe"
    ))
    | project Timestamp, DeviceName, AccountName = InitiatingProcessAccountName,
        FileName = InitiatingProcessFileName,
        ProcessCommandLine = InitiatingProcessCommandLine,
        InitiatingProcessFileName,
        InitiatingProcessCommandLine,
        FolderPath = InitiatingProcessFolderPath,
        DetectionVector = "SuspiciousAccess";
// Vector 3: LSASS memory dump files created on disk
let LsassDumpFiles = DeviceFileEvents
    | where Timestamp > ago(TimeWindow)
    | where ActionType == "FileCreated"
    | where (
        (FileName has "lsass" and FileName has_any (".dmp", ".dump", ".bin", ".tmp"))
        or (FolderPath has "\\Windows\\Temp\\" and FileName endswith ".dmp"
            and FileSize > 20000000)
    )
    | project Timestamp, DeviceName, AccountName = InitiatingProcessAccountName,
        FileName, ProcessCommandLine = InitiatingProcessCommandLine,
        InitiatingProcessFileName,
        InitiatingProcessCommandLine = "",
        FolderPath,
        DetectionVector = "DumpFileCreated";
// Combine all vectors
union ToolBasedDumping, ProcessAccessToLSASS, LsassDumpFiles
| sort by Timestamp desc
| project-reorder Timestamp, DeviceName, DetectionVector, AccountName,
    FileName, ProcessCommandLine, InitiatingProcessFileName, FolderPath
```

### Expected Findings

- **Direct tool usage.** Execution of Mimikatz (or recompiled variants) with `sekurlsa::logonpasswords` or similar commands. These are high-confidence indicators.
- **ProcDump abuse.** `procdump.exe -ma lsass.exe` is a well-documented technique using a legitimate Sysinternals tool to dump LSASS memory.
- **comsvcs.dll MiniDump.** `rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump <lsass_pid> C:\temp\out.dmp full` abuses a built-in DLL to dump process memory.
- **Unknown processes accessing LSASS.** Any non-system process reading LSASS memory is suspicious and requires investigation.
- **Large .dmp files** in Temp or other writable directories that appear around the same time as suspicious LSASS access.

### Triage Steps

1. **Confirm the detection.** Review the full process tree and command line. Determine whether this is a security tool (EDR, AV) performing legitimate LSASS inspection or a true credential dump.
2. **Identify the dumping method.** The method indicates adversary sophistication: Mimikatz is common but noisy; comsvcs.dll and direct API calls are more evasion-aware.
3. **Determine what credentials were exposed.** Check which users were logged into the target machine at the time of the dump. All their credentials should be considered compromised.
4. **Scope the impact.** If a domain admin was logged into the compromised machine, the entire domain may be at risk.
5. **Check for dump file exfiltration.** Query `DeviceNetworkEvents` for outbound transfers from the device after the dump was created.

### False Positive Guidance

- **Antivirus and EDR agents** legitimately access LSASS for protection purposes. The query excludes known agents (MsMpEng.exe, SenseIR.exe), but you may need to add your specific security tools.
- **Windows Credential Guard** health checks and related system processes access LSASS. These originate from known system binaries.
- **Crash dump generation** by Windows Error Reporting (WerFault.exe) can create LSASS dump files during legitimate system crashes.

### Recommended Response Actions

- **IMMEDIATE:** If credential dumping is confirmed, treat this as a high-severity incident. The attacker likely has harvested credentials for all users who were authenticated on that machine.
- Isolate the affected endpoint.
- Reset passwords for ALL accounts that were logged into the machine (interactive, service, cached).
- If any compromised account is a domain admin, initiate a full domain compromise investigation. Consider resetting the KRBTGT account (twice, 12 hours apart).
- Review Credential Guard and LSA protection (RunAsPPL) deployment status across the environment.
- Enable ASR rule "Block credential stealing from the Windows local security authority subsystem" if not already active.

---

## Hunt 6 — Azure AD Suspicious Activity

### Hypothesis

Cloud identities in Azure Active Directory are being targeted for initial access, persistence, or privilege escalation. Adversaries may be replaying stolen tokens, abusing OAuth consent grants to gain persistent access to user data, modifying application permissions to establish backdoors, or leveraging cross-tenant trust relationships. Service principals are of particular concern because they often have high privileges and are monitored less closely than user accounts.

### MITRE ATT&CK Mapping

| Field | Value |
|---|---|
| **Tactic** | Initial Access (TA0001), Persistence (TA0003), Privilege Escalation (TA0004) |
| **Technique** | T1078.004 — Valid Accounts: Cloud Accounts |
| **Related** | T1550.001 (Application Access Token), T1098.003 (Additional Cloud Roles) |

### Required Data Sources

- `SigninLogs` (Azure AD interactive sign-ins)
- `AADNonInteractiveUserSignInLogs` (Azure AD non-interactive/token sign-ins)
- `AuditLogs` (Azure AD administrative and configuration changes)
- `CloudAppEvents` (Defender for Cloud Apps)

### Hunting Query — Token Replay Detection

```kql
// Hunt: Token Replay - Same token used from different IPs/locations
// Adversaries steal OAuth tokens and replay them from their infrastructure
let TimeWindow = 7d;
SigninLogs
| where TimeGenerated > ago(TimeWindow)
| where ResultType == 0  // Successful sign-ins only
| extend TokenIssueTime = tostring(AuthenticationDetails)
| summarize
    UniqueIPs = dcount(IPAddress),
    IPAddresses = make_set(IPAddress, 10),
    Locations = make_set(Location, 10),
    UniqueLocations = dcount(Location),
    AppNames = make_set(AppDisplayName, 5),
    SignInCount = count(),
    FirstSeen = min(TimeGenerated),
    LastSeen = max(TimeGenerated)
    by UserPrincipalName, CorrelationId
| where UniqueIPs > 1
// A single correlation ID appearing from multiple IPs suggests token theft/replay
| extend TimeDelta = datetime_diff("minute", LastSeen, FirstSeen)
// Short time windows with multiple IPs are most suspicious
| where TimeDelta < 60 and UniqueIPs >= 2
| sort by UniqueIPs desc
```

### Hunting Query — Illicit Consent Grant / OAuth Abuse

```kql
// Hunt: OAuth Consent Grant Abuse
// Adversaries trick users into granting excessive permissions to malicious apps
// or register apps with high-privilege API permissions
let TimeWindow = 14d;
// Part 1: User consent grants to applications
let ConsentGrants = AuditLogs
    | where TimeGenerated > ago(TimeWindow)
    | where OperationName == "Consent to application"
    | extend GrantInitiatedBy = tostring(InitiatedBy.user.userPrincipalName)
    | extend AppName = tostring(TargetResources[0].displayName)
    | extend AppId = tostring(TargetResources[0].id)
    | extend ConsentedPermissions = tostring(
        parse_json(tostring(TargetResources[0].modifiedProperties))[4].newValue)
    | project TimeGenerated, GrantInitiatedBy, AppName, AppId,
        ConsentedPermissions, CorrelationId
    | extend PermissionType = "UserConsent";
// Part 2: Application permission changes (admin consent / app role assignments)
let AppPermissionChanges = AuditLogs
    | where TimeGenerated > ago(TimeWindow)
    | where OperationName in (
        "Add app role assignment to service principal",
        "Add delegated permission grant",
        "Add application",
        "Update application"
    )
    | extend InitiatedByUser = tostring(InitiatedBy.user.userPrincipalName)
    | extend InitiatedByApp = tostring(InitiatedBy.app.displayName)
    | extend TargetApp = tostring(TargetResources[0].displayName)
    | extend ModifiedProperties = parse_json(
        tostring(TargetResources[0].modifiedProperties))
    | project TimeGenerated,
        GrantInitiatedBy = coalesce(InitiatedByUser, InitiatedByApp),
        AppName = TargetApp,
        AppId = tostring(TargetResources[0].id),
        ConsentedPermissions = tostring(ModifiedProperties),
        CorrelationId,
        PermissionType = "AdminOrAppPermission";
union ConsentGrants, AppPermissionChanges
| sort by TimeGenerated desc
```

### Hunting Query — Service Principal Anomalies

```kql
// Hunt: Service Principal Anomalous Activity
// Service principals with new credential additions or unusual sign-in patterns
let TimeWindow = 7d;
// New credentials added to service principals (potential backdoor)
let NewSPCredentials = AuditLogs
    | where TimeGenerated > ago(TimeWindow)
    | where OperationName in (
        "Add service principal credentials",
        "Update application - Certificates and secrets management"
    )
    | extend InitiatedBy = coalesce(
        tostring(InitiatedBy.user.userPrincipalName),
        tostring(InitiatedBy.app.displayName))
    | extend TargetSP = tostring(TargetResources[0].displayName)
    | extend TargetSPId = tostring(TargetResources[0].id)
    | project TimeGenerated, InitiatedBy, TargetSP, TargetSPId,
        OperationName, CorrelationId;
// Service principal sign-ins from unusual locations
let SPSignIns = AADServicePrincipalSignInLogs
    | where TimeGenerated > ago(TimeWindow)
    | where ResultType == 0
    | summarize
        UniqueIPs = dcount(IPAddress),
        IPList = make_set(IPAddress, 20),
        AppCount = dcount(ResourceDisplayName),
        SignInCount = count()
        by ServicePrincipalName, ServicePrincipalId
    | where UniqueIPs > 3;
NewSPCredentials
| join kind=leftouter SPSignIns on $left.TargetSPId == $right.ServicePrincipalId
| project-reorder TimeGenerated, TargetSP, InitiatedBy, OperationName,
    UniqueIPs, IPList, SignInCount
| sort by TimeGenerated desc
```

### Expected Findings

- **Token replay.** The same authentication session appearing from multiple IP addresses, especially from different geographic locations within a short time window.
- **Illicit consent grants.** Users granting OAuth permissions to applications that request Mail.Read, Files.ReadWrite, or other sensitive scopes. These applications may have generic or misleading names.
- **Backdoor credentials on service principals.** New secrets or certificates added to existing service principals by users who are not the application owners.
- **Role assignments to unexpected principals.** Global Administrator or Application Administrator roles assigned to new accounts or service principals.
- **Cross-tenant anomalies.** Sign-ins from service principals in unexpected tenants, or new B2B trust configurations.

### Triage Steps

1. **For token replay.** Verify whether the user was genuinely traveling or using a VPN. Check if the IP addresses belong to known VPN providers or corporate egress points. If not, revoke the user's sessions and tokens immediately.
2. **For consent grants.** Review the application's publisher, registration date, and requested permissions. Unverified publishers requesting high-privilege permissions are high-risk. Revoke the consent and remove the enterprise application.
3. **For service principal credential additions.** Verify with the application owner whether the credential change was authorized. Unauthorized credential additions are a high-severity finding.
4. **For role changes.** Confirm with IAM team whether the role assignment was part of an approved change request.

### False Positive Guidance

- **Legitimate VPN usage** can cause sign-ins from multiple IPs. Maintain a list of corporate VPN egress IPs.
- **Multi-cloud architectures** may cause service principal sign-ins from diverse IP ranges. Baseline expected IP ranges for each service principal.
- **Application registration during development** may trigger credential and permission change alerts. Correlate with development team change requests.

### Recommended Response Actions

- Revoke compromised tokens using `Revoke-AzureADUserAllRefreshToken` or the Azure portal.
- Remove unauthorized OAuth consent grants from the enterprise applications blade.
- Rotate credentials for any service principal with unauthorized credential additions.
- Enable Conditional Access policies requiring compliant devices and known locations for sensitive applications.
- Implement an admin consent workflow to prevent users from granting consent to arbitrary applications.

---

## Hunt 7 — Data Staging and Exfiltration Preparation

### Hypothesis

An insider threat or an external attacker with established access is staging sensitive data for exfiltration. Before data leaves the network, it is typically collected from multiple sources and consolidated into archive files in a staging location. This preparation phase creates observable artifacts: archive tool execution, large file creation in temporary directories, and unusual file access patterns by a single account.

### MITRE ATT&CK Mapping

| Field | Value |
|---|---|
| **Tactic** | Collection (TA0009), Exfiltration (TA0010) |
| **Technique** | T1074 — Data Staged, T1074.001 — Local Data Staging |
| **Related** | T1560 (Archive Collected Data), T1560.001 (Archive via Utility) |

### Required Data Sources

- `DeviceProcessEvents` (Defender for Endpoint)
- `DeviceFileEvents` (Defender for Endpoint)
- `DeviceNetworkEvents` (Defender for Endpoint)

### Hunting Query (KQL)

```kql
// Hunt: Data Staging - Archive creation in unusual locations and contexts
// Scope: Last 14 days
let TimeWindow = 14d;
let StagingPaths = dynamic([
    "\\temp\\", "\\tmp\\", "\\users\\public\\",
    "\\perflogs\\", "\\programdata\\",
    "\\appdata\\local\\temp\\", "\\downloads\\",
    "\\recycle", "\\windows\\temp\\"
]);
let ArchiveExtensions = dynamic([".zip", ".7z", ".rar", ".tar", ".gz",
    ".tar.gz", ".cab", ".bz2", ".xz"]);
let ArchiveTools = dynamic(["7z.exe", "7za.exe", "rar.exe", "winrar.exe",
    "tar.exe", "compact.exe", "makecab.exe", "powershell.exe"]);
// Part 1: Archive tool execution in suspicious contexts
let ArchiveToolUsage = DeviceProcessEvents
    | where Timestamp > ago(TimeWindow)
    | where FileName in~ (ArchiveTools) or ProcessCommandLine has_any (
        "Compress-Archive", "IO.Compression", "ZipFile",
        "System.IO.Compression", "tar -c", "makecab"
    )
    // Look for archive operations targeting staging paths
    | where ProcessCommandLine has_any (StagingPaths)
        or FolderPath has_any (StagingPaths)
    // Exclude known backup and deployment processes
    | where not(InitiatingProcessFileName in~ (
        "backupexec.exe", "veeam", "sccm", "intune"))
    | project Timestamp, DeviceName, AccountName,
        FileName, ProcessCommandLine,
        InitiatingProcessFileName, InitiatingProcessCommandLine,
        DetectionType = "ArchiveToolExecution";
// Part 2: Large archive files created in staging locations
let LargeArchiveCreation = DeviceFileEvents
    | where Timestamp > ago(TimeWindow)
    | where ActionType == "FileCreated"
    | where FileName has_any (ArchiveExtensions)
    | where FolderPath has_any (StagingPaths)
    | where FileSize > 50000000  // Greater than 50 MB
    | project Timestamp, DeviceName,
        AccountName = InitiatingProcessAccountName,
        FileName, ProcessCommandLine = InitiatingProcessCommandLine,
        InitiatingProcessFileName,
        InitiatingProcessCommandLine = "",
        FolderPath,
        DetectionType = "LargeArchiveCreated",
        FileSizeMB = FileSize / 1048576;
// Part 3: PowerShell compression commands
let PSCompression = DeviceProcessEvents
    | where Timestamp > ago(TimeWindow)
    | where FileName =~ "powershell.exe" or FileName =~ "pwsh.exe"
    | where ProcessCommandLine has_any (
        "Compress-Archive", "[System.IO.Compression",
        "[IO.Compression.ZipFile]", "GZipStream",
        "DeflateStream", "CreateFromDirectory"
    )
    | project Timestamp, DeviceName, AccountName,
        FileName, ProcessCommandLine,
        InitiatingProcessFileName, InitiatingProcessCommandLine,
        DetectionType = "PowerShellCompression";
union ArchiveToolUsage, LargeArchiveCreation, PSCompression
| sort by Timestamp desc
| project-reorder Timestamp, DeviceName, DetectionType, AccountName,
    FileName, ProcessCommandLine
```

### Correlation with Subsequent Network Activity

```kql
// Supplemental: After identifying staging activity, check for data leaving the network
// Run this query with the DeviceName and time window from the primary hunt
let StagingDevice = "WORKSTATION-001";  // Replace with device from primary hunt
let StagingTime = datetime(2026-02-01T12:00:00Z);  // Replace with staging timestamp
DeviceNetworkEvents
| where Timestamp between (StagingTime .. (StagingTime + 4h))
| where DeviceName =~ StagingDevice
| where ActionType == "ConnectionSuccess"
| where RemotePort in (443, 80, 22, 21, 8080, 8443)
| where not(RemoteUrl has_any (
    "microsoft.com", "windows.com", "windowsupdate.com",
    "office365.com", "office.com"
))
| summarize
    TotalConnections = count(),
    TotalBytesSent = sum(SentBytes),
    UniqueDestinations = dcount(RemoteUrl),
    Destinations = make_set(RemoteUrl, 20)
    by DeviceName, bin(Timestamp, 15m)
| where TotalBytesSent > 10000000  // More than 10 MB sent in a 15-minute window
| sort by TotalBytesSent desc
```

### Expected Findings

- **Archive tool execution in temp directories.** 7zip or WinRAR being used to create archives in `C:\Users\Public\`, `C:\Temp\`, or similar staging locations.
- **PowerShell compression.** Scripts using `Compress-Archive` or `System.IO.Compression` to create zip files programmatically.
- **Unusual file access volume.** A single account accessing a large number of files from file shares or SharePoint before archive creation.
- **Large outbound transfers.** Following archive creation, large data volumes sent to external destinations via HTTPS, cloud storage, or file sharing services.

### Triage Steps

1. **Identify the user.** Determine whether the account has a legitimate business reason to collect and archive the data in question.
2. **Examine what data was staged.** If possible, determine what files were added to the archive. Review `DeviceFileEvents` for file reads by the same account in the preceding hours.
3. **Check the archive destination.** Was the archive moved, copied, or uploaded after creation? Look for subsequent file copy events, email attachments, or cloud upload activity.
4. **Review the user's recent activity.** Check for other unusual behaviors: off-hours access, access to systems outside their normal scope, use of personal cloud storage.
5. **Involve HR and Legal if insider threat is suspected.** Insider threat investigations require coordination beyond the SOC.

### False Positive Guidance

- **Backup operations** and software deployments create archives in standard paths. Correlate with IT operations schedules.
- **Developers and data analysts** may legitimately create large archives. Validate against job function and project assignments.
- **File server maintenance** (compression for archival) generates expected archive creation events.

### Recommended Response Actions

- If unauthorized data staging is confirmed, preserve all evidence before taking action.
- Restrict the user's network access and cloud storage permissions.
- Determine the sensitivity of the staged data (PII, financial, intellectual property).
- If exfiltration has already occurred, determine the destination and engage the incident response process.
- Report to appropriate stakeholders (Legal, HR, Compliance) per the insider threat response plan.

---

## Hunt 8 — Email-Based Initial Access Indicators

### Hypothesis

Phishing emails have bypassed email security controls (Microsoft Defender for Office 365, third-party email gateway) and were delivered to user mailboxes. Some of these emails may have been interacted with, resulting in malicious attachments being opened or links being clicked. The goal of this hunt is to find the gap between email delivery and endpoint compromise by correlating email events with subsequent suspicious process execution on the recipient's device.

### MITRE ATT&CK Mapping

| Field | Value |
|---|---|
| **Tactic** | Initial Access (TA0001) |
| **Technique** | T1566 — Phishing |
| **Sub-techniques** | T1566.001 (Spearphishing Attachment), T1566.002 (Spearphishing Link) |

### Required Data Sources

- `EmailEvents` (Defender for Office 365)
- `EmailAttachmentInfo` (Defender for Office 365)
- `EmailUrlInfo` (Defender for Office 365)
- `DeviceProcessEvents` (Defender for Endpoint)
- `DeviceFileEvents` (Defender for Endpoint)

### Hunting Query — Post-Delivery Weaponization via Attachments

```kql
// Hunt: Phishing - Email attachment delivery followed by suspicious process execution
// Scope: Last 7 days
let TimeWindow = 7d;
// Step 1: Find delivered emails with potentially weaponized attachments
let SuspiciousAttachments = EmailAttachmentInfo
    | where Timestamp > ago(TimeWindow)
    | where FileType in~ (
        "docm", "xlsm", "pptm",          // Macro-enabled Office
        "doc", "xls", "ppt",              // Legacy Office (can contain macros)
        "iso", "img", "vhd", "vhdx",      // Disk images (bypass MotW)
        "lnk",                             // Shortcut files
        "html", "htm", "hta",             // HTML smuggling
        "js", "jse", "vbs", "vbe", "wsf", // Script files
        "exe", "dll", "scr", "bat", "cmd", // Executables
        "zip", "rar", "7z", "cab"          // Archives (may contain above types)
    )
    | join kind=inner (
        EmailEvents
        | where Timestamp > ago(TimeWindow)
        | where DeliveryAction == "Delivered"
        | project NetworkMessageId, RecipientEmailAddress, SenderFromAddress,
            Subject, DeliveryAction, EmailTimestamp = Timestamp
    ) on NetworkMessageId
    | project EmailTimestamp, NetworkMessageId, RecipientEmailAddress,
        SenderFromAddress, Subject, FileName, FileType, SHA256;
// Step 2: Correlate with endpoint activity
// Map email recipients to device users and look for suspicious child processes
// from Office applications within 30 minutes of email delivery
let OfficeProcesses = dynamic(["winword.exe", "excel.exe", "powerpnt.exe",
    "outlook.exe", "msedge.exe", "chrome.exe", "firefox.exe"]);
let SuspiciousChildren = dynamic(["powershell.exe", "pwsh.exe", "cmd.exe",
    "wscript.exe", "cscript.exe", "mshta.exe", "certutil.exe",
    "rundll32.exe", "regsvr32.exe", "schtasks.exe", "bitsadmin.exe",
    "net.exe", "net1.exe"]);
let PostDeliveryExecution = DeviceProcessEvents
    | where Timestamp > ago(TimeWindow)
    | where InitiatingProcessFileName in~ (OfficeProcesses)
    | where FileName in~ (SuspiciousChildren)
    | project ProcessTimestamp = Timestamp, DeviceName, AccountName,
        ParentProcess = InitiatingProcessFileName,
        ChildProcess = FileName,
        ChildCommandLine = ProcessCommandLine,
        ParentCommandLine = InitiatingProcessCommandLine;
// Step 3: Join email delivery with endpoint execution
// Using time window correlation (within 30 minutes of delivery)
SuspiciousAttachments
| join kind=inner (
    PostDeliveryExecution
    | extend AccountEmail = strcat(AccountName, "@")  // Partial match for correlation
) on $left.RecipientEmailAddress has $right.AccountEmail
| where ProcessTimestamp between (EmailTimestamp .. (EmailTimestamp + 30m))
| project
    EmailTimestamp,
    ProcessTimestamp,
    TimeDelta = datetime_diff("minute", ProcessTimestamp, EmailTimestamp),
    RecipientEmailAddress,
    SenderFromAddress,
    Subject,
    AttachmentName = FileName,
    AttachmentType = FileType,
    DeviceName,
    ParentProcess,
    ChildProcess,
    ChildCommandLine
| sort by EmailTimestamp desc
```

### Hunting Query — Link-Click Followed by Download

```kql
// Hunt: Phishing link click followed by file download and execution
// Scope: Last 7 days
let TimeWindow = 7d;
// Identify URLs from delivered emails that were clicked
let ClickedEmailUrls = EmailUrlInfo
    | where Timestamp > ago(TimeWindow)
    | join kind=inner (
        EmailEvents
        | where Timestamp > ago(TimeWindow)
        | where DeliveryAction == "Delivered"
    ) on NetworkMessageId
    | where UrlLocation == "Body"
    | project EmailTimestamp = Timestamp, Url, NetworkMessageId,
        RecipientEmailAddress, SenderFromAddress, Subject;
// Look for browser-initiated downloads followed by execution
let BrowserDownloads = DeviceFileEvents
    | where Timestamp > ago(TimeWindow)
    | where ActionType == "FileCreated"
    | where InitiatingProcessFileName in~ ("msedge.exe", "chrome.exe",
        "firefox.exe", "iexplore.exe")
    | where FileName has_any (".exe", ".dll", ".scr", ".hta", ".js",
        ".vbs", ".ps1", ".bat", ".cmd", ".msi", ".iso", ".img", ".lnk")
    | project DownloadTimestamp = Timestamp, DeviceName,
        DownloadedFile = FileName, DownloadPath = FolderPath,
        BrowserProcess = InitiatingProcessFileName,
        DownloadSHA256 = SHA256,
        AccountName = InitiatingProcessAccountName;
// Check if downloaded files were subsequently executed
let FileExecutions = DeviceProcessEvents
    | where Timestamp > ago(TimeWindow)
    | project ExecTimestamp = Timestamp, DeviceName,
        ExecutedFile = FileName, ExecCommandLine = ProcessCommandLine,
        ExecSHA256 = SHA256;
BrowserDownloads
| join kind=inner FileExecutions
    on DeviceName, $left.DownloadedFile == $right.ExecutedFile
| where ExecTimestamp between (DownloadTimestamp .. (DownloadTimestamp + 10m))
| project
    DownloadTimestamp,
    ExecTimestamp,
    TimeDelta = datetime_diff("second", ExecTimestamp, DownloadTimestamp),
    DeviceName,
    AccountName,
    DownloadedFile,
    DownloadPath,
    BrowserProcess,
    ExecCommandLine,
    DownloadSHA256
| sort by DownloadTimestamp desc
```

### Expected Findings

- **Office macro execution.** `winword.exe` or `excel.exe` spawning `powershell.exe`, `cmd.exe`, or `wscript.exe` shortly after a macro-enabled document was delivered via email.
- **HTML smuggling.** Browser processes creating executable files in the Downloads directory, followed by execution.
- **ISO/IMG mounting.** Disk image files delivered via email, mounted by Explorer, with subsequent execution of contained payloads (commonly LNK files pointing to DLLs).
- **Link-to-download chains.** User clicks a URL from an email, browser downloads an executable or script, and the file is executed within minutes.

### Triage Steps

1. **Analyze the email.** Review the sender, subject, and attachment/URL in the Defender for Office 365 threat explorer. Check if other recipients received the same email.
2. **Check the attachment or downloaded file.** Submit the SHA256 hash to VirusTotal and internal sandboxing. For URLs, check reputation and whether they are newly registered domains.
3. **Examine the child process.** What did the spawned process (PowerShell, cmd, etc.) actually do? Review the full command line for download cradles, encoded commands, or lateral movement.
4. **Determine the blast radius.** How many users received the same email? How many clicked or opened? Use Defender for Office 365 threat explorer to scope the campaign.
5. **Check for persistence.** If the payload executed, hunt for persistence mechanisms on the affected endpoint using the queries from Hunt 4.

### False Positive Guidance

- **Legitimate macro-enabled documents** are still used in some business workflows. Identify departments that use macros and create context-aware exclusions.
- **Software downloads via email links** (legitimate SaaS onboarding) can trigger download-then-execute patterns. Validate against known application domains.
- **IT deployment emails** with attached scripts or installers may trigger attachment-based detections.

### Recommended Response Actions

- If a phishing email was delivered and interacted with, immediately purge the email from all recipient mailboxes using Defender for Office 365 remediation actions.
- Isolate endpoints where payloads executed.
- Block sender addresses, domains, and payload URLs/hashes across email and web security controls.
- Notify all recipients who received but may not have opened the email.
- If the phishing email bypassed existing rules, analyze why and create a mail flow rule or detection override to catch similar messages.
- Submit the campaign details to Microsoft via the admin submission portal to improve future detection.

---

## Operationalizing Threat Hunting

### Establishing a Hunting Cadence

A sustainable threat hunting program operates on a regular cadence rather than ad hoc. The following schedule balances thoroughness with analyst capacity:

| Cadence | Activity |
|---|---|
| **Weekly** | Execute 1-2 hunts from the prioritized backlog. Focus on hunts aligned with current threat intelligence. |
| **Bi-weekly** | Review hunting backlog and reprioritize based on new intelligence, incidents, or environmental changes. |
| **Monthly** | Conduct a hunting retrospective: review completed hunts, document findings, and assess detection gap closures. |
| **Quarterly** | Perform a MITRE ATT&CK coverage assessment. Identify techniques with no detection rules and no recent hunts. Generate new hypotheses for uncovered areas. |

### Documentation Standards

Every completed hunt must be documented with:

1. **Hypothesis** (as stated before the hunt).
2. **Date range and scope** (which devices, users, or segments were included).
3. **Queries used** (versioned and stored in the hunting query repository).
4. **Findings** (what was found, what was investigated, what was ruled out).
5. **Outcome** (true positive escalated, no findings, or data gap identified).
6. **Recommendations** (new detection rules, logging improvements, configuration changes).

This documentation serves three purposes: it builds institutional knowledge, it provides evidence for compliance audits, and it feeds the detection engineering pipeline.

### Feedback Loop to Detection Engineering

Threat hunting and detection engineering are two sides of the same coin. The feedback loop works as follows:

1. **Hunt discovers new TTP.** A hunt identifies attacker behavior that was not previously detected by automated rules.
2. **Create detection rule.** The hunting query is refined into a scheduled analytic rule in Sentinel or a custom detection in Defender. The rule is tuned based on the false positive analysis performed during the hunt.
3. **Validate detection rule.** The new rule is tested against historical data and monitored for false positive rates during a tuning period.
4. **Promote to production.** Once tuned, the rule enters the production detection pipeline, and the corresponding threat is now covered by automated alerting.
5. **Hunt for evasion.** Future hunts include variations of the detected TTP, anticipating that adversaries will adapt their techniques to evade the new rule.

### Measuring Hunting Program Effectiveness

| Metric | Description | Target |
|---|---|---|
| **Hunts completed per month** | Number of structured hunts executed | 4-6 |
| **True positive rate** | Percentage of hunts that yield confirmed findings | 10-20% (higher suggests scope is too narrow) |
| **Mean time to detect (for hunt-discovered incidents)** | Time from compromise to detection via hunting | Less than environment median dwell time |
| **Detection rules generated** | Number of new automated detections created from hunt findings | 1-2 per month |
| **Data gap closures** | Number of logging/coverage gaps identified and remediated | Track quarterly |
| **MITRE ATT&CK coverage improvement** | Percentage of ATT&CK techniques with at least one detection or recent hunt | Increasing quarter over quarter |
| **Hunt hypothesis backlog size** | Number of pending hypotheses awaiting investigation | 15-30 (healthy backlog) |

### Continuous Improvement

The hunting program should evolve over time:

- **Automate graduated hunts.** Queries that consistently produce useful results should become scheduled analytics, freeing analyst time for new hypotheses.
- **Expand data sources.** Each quarter, evaluate whether new log sources (cloud workloads, OT/IoT, SaaS applications) should be onboarded to support broader hunting.
- **Invest in tooling.** Jupyter notebooks for statistical analysis, SOAR playbooks for hunt result enrichment, and threat intelligence platform integration improve hunt efficiency.
- **Cross-train analysts.** Rotate hunting responsibilities across the team to build skills and prevent knowledge silos.

---

## References

### Frameworks and Methodologies

- **MITRE ATT&CK Framework** — https://attack.mitre.org — Primary taxonomy for mapping adversary techniques to hunting hypotheses.
- **MITRE ATT&CK Navigator** — https://mitre-attack.github.io/attack-navigator/ — Visual tool for assessing detection coverage and identifying hunting priorities.
- **Sqrrl Threat Hunting Reference Model** — Hypothesis-driven hunting methodology that informed the approach used in this document.
- **PEAK Threat Hunting Framework** — https://www.splunk.com/en_us/blog/security/peak-threat-hunting-framework.html — Structured framework for Prepare, Execute, and Act with Knowledge.
- **TaHiTI (Targeted Hunting integrating Threat Intelligence)** — European methodology for integrating threat intelligence into hunting workflows.

### Data Sources and Query Languages

- **Microsoft KQL Reference** — https://learn.microsoft.com/en-us/azure/data-explorer/kusto/query/ — Complete Kusto Query Language documentation.
- **Microsoft Sentinel Hunting** — https://learn.microsoft.com/en-us/azure/sentinel/hunting — Hunting capabilities within Microsoft Sentinel.
- **Defender for Endpoint Advanced Hunting** — https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/advanced-hunting-overview — Schema reference and query examples.
- **Elastic SIEM Detection Rules** — https://github.com/elastic/detection-rules — Open-source detection rules that serve as hunting starting points.

### Technique-Specific References

- **LOLBAS Project** — https://lolbas-project.github.io — Catalog of Living Off the Land Binaries, Scripts, and Libraries.
- **Sigma Rules** — https://github.com/SigmaHQ/sigma — Generic signature format that can be converted to KQL, SPL, and other query languages.
- **Atomic Red Team** — https://github.com/redcanaryco/atomic-red-team — Library of tests mapped to MITRE ATT&CK for validating hunting queries.

---

*This document is maintained as part of an active threat hunting program. Hypotheses, queries, and baselines are reviewed and updated quarterly to reflect the evolving threat landscape and changes in the environment.*

*Jacob Phillips — Cloud Security Engineer — SC-200 Certified*
